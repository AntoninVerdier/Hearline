import librosa
import argparse
import numpy as np
import os
import QuickSound.Sound as Sound
import numpy as np 
import matplotlib.pyplot as plt

from rich.progress import track

from multiprocessing import Pool, Manager


samplerate = 64000
amplitude = 70
noise_amplitude = 60
duration = 500
path = 'Clean_sounds_datasetv2_60_28k'
path_noise = 'Noise_sounds_datasetv2_60_28k'

parser = argparse.ArgumentParser(description='Add noise or not')

parser.add_argument('--noise', '-n', action='store_true',
					help='Add noise')

args = parser.parse_args()



# Do we care after several amplitude ?

if not os.path.exists(path):
	os.makedirs(path)
if not os.path.exists(path_noise):
	os.makedirs(path_noise)

np.random.seed(432754448)

# Pure tone frequencies
pts = np.random.randint(low=500, high=28000, size=3000, dtype=int)

carryam_frequencies = np.random.randint(low=6000, high=16000, size=3000, dtype=int)
am_frequencies = np.random.randint(low=10, high=200, size=3000, dtype=int)
ams = [(cam, fam) for cam, fam in zip(carryam_frequencies, am_frequencies)]


chirps= np.random.randint(low=500, high=20000, size=(3000, 2), dtype=int)

step_ranges = np.random.randint(low=500, high=20000, size=(3000, 2), dtype=int)
step_size = np.random.randint(low=2, high=60, size=(3000, 1), dtype=int)
steps = np.concatenate([step_ranges, step_size], axis=1)

funda_harm = np.random.randint(low=1000, high=10000, size=200)
patt_harms= np.random.randint(low=0, high=2, size=(20, 5))
patt_harms = np.arange(1, 6) * patt_harms
harmonics = np.array([f*patt for f in funda_harm for patt in patt_harms])
harmonics[harmonics > 28000] = 0
harmonics = [[i for i in h if i != 0] for h in harmonics]
fs = [h for h in harmonics if len(h) > 0]


# Hard coding amplitude for boxes
dBref = 100
A = 10**((noise_amplitude-dBref)/20)

wham_dataset = '/home/user/Documents/Antonin/Dimmy/cv'
random_picked_noise = np.random.choice([w for w in os.listdir(wham_dataset)], size=800)
random_picked_noise = [librosa.load(os.path.join(wham_dataset, r), sr=16000, duration=2)[0] for r in random_picked_noise]
random_picked_noise = [A * (r - np.max(r))/(np.max(r) - np.min(r)) for r in random_picked_noise]

random_white_noise = [Sound(amplitude=noise_amplitude, samplerate=samplerate) for i in range(200)]
for r in random_white_noise: r.noise(duration)
random_white_noise = [r.signal for r in random_white_noise]
random_noise = random_picked_noise + random_white_noise


# Generate pure_tones
def gen_pt(f, noise):
	pure = Sound(amplitude=amplitude, samplerate=samplerate)
	pure.pure_tone(f, duration=duration)
	if noise is not None:
		pure.save_wav(name='PT_{}_{}ms_{}dB_noise{}'.format(f, duration, amplitude, noise), path=path)
		pure.signal += random_noise[np.random.choice(np.arange(1000))]
		pure.save_wav(name='PT_{}_{}ms_{}dB_noise{}'.format(f, duration, amplitude, noise), path=path_noise)

	else:
		pure.save_wav(name='PT_{}_{}ms_{}dB'.format(f, duration, amplitude), path=path)

# Can generate two sets of independent variable
def gen_am(ams, noise):
	am = Sound(amplitude=amplitude, samplerate=samplerate)
	am.amplitude_modulation(ams[0], ams[1], duration=duration)
	if noise is not None:
		am.save_wav(name='AM_{}_{}_{}ms_{}dB_noise{}'.format(ams[0], ams[1], duration, amplitude, noise), path=path)
		am.signal += random_noise[np.random.choice(np.arange(1000))]
		am.save_wav(name='AM_{}_{}_{}ms_{}dB_noise{}'.format(ams[0], ams[1], duration, amplitude, noise), path=path_noise)
	else:
		am.save_wav(name='AM_{}_{}_{}ms_{}dB'.format(ams[0], ams[1], duration, amplitude), path=path)

# Chirp can be generated by controlled ints
def gen_chirps(c, noise):
	chirp = Sound(amplitude=amplitude, samplerate=samplerate)
	chirp.freq_modulation(c[0], c[1], duration=duration)
	if noise is not None:
		chirp.save_wav(name='Chirp_{}_{}_{}ms_{}dB_noise{}'.format(c[0], c[1], duration, amplitude, noise), path=path)
		chirp.signal += random_noise[np.random.choice(np.arange(1000))]
		chirp.save_wav(name='Chirp_{}_{}_{}ms_{}dB_noise{}'.format(c[0], c[1], duration, amplitude, noise), path=path_noise)
	else:
		chirp.save_wav(name='Chirp_{}_{}_{}ms_{}dB'.format(c[0], c[1], duration, amplitude), path=path)

def gen_steps(s, noise):
	step = Sound(amplitude=amplitude, samplerate=samplerate)
	try:
		step.steps(s[0], s[1], s[2], spacing='Log', duration=duration)
		if noise is not None:
			step.save_wav(name='Step_{}_{}_{}_{}ms_{}dB_noise{}'.format(s[0], s[1], s[2], duration, amplitude, noise), path=path)
			step.signal += random_noise[np.random.choice(np.arange(1000))]
			step.save_wav(name='Step_{}_{}_{}_{}ms_{}dB_noise{}'.format(s[0], s[1], s[2], duration, amplitude, noise), path=path_noise)
		else:
			step.save_wav(name='Step_{}_{}_{}_{}ms_{}dB'.format(s[0], s[1], s[2], duration, amplitude), path=path)
	except Exception as e:
		print(e)

def gen_fmul(fs, noise):
	fmul = Sound(amplitude=amplitude, samplerate=samplerate)
	fmul.multi_freqs(fs, duration=duration)
	if noise is not None:
		fmul.save_wav(name='Harm_{}_{}ms_{}dB_noise{}'.format(fs, duration, amplitude, noise), path=path)
		fmul.signal += random_noise[np.random.choice(np.arange(1000))]
		fmul.save_wav(name='Harm_{}_{}ms_{}dB_noise{}'.format(fs, duration, amplitude, noise), path=path_noise)
	fmul.save_wav(name='Harm_{}_{}ms_{}dB'.format(fs, duration, amplitude), path=path)

def gen_multi(function, args, noise=False):
	with Pool() as p:
		results = [p.apply_async(function, args=(a, noise)) for a in args]
		dataset = [p.get() for p in track(results, description='Generating sounds ...')]

if __name__ == '__main__':
	# To get only a clean dataset, remove -n arg otherwise if -n it will give both datasets
	if args.noise:
		for i in range(7):
			gen_multi(gen_pt, pts, noise=i)
			gen_multi(gen_am, ams, noise=i)
			gen_multi(gen_chirps, chirps, noise=i)
			gen_multi(gen_steps, steps, noise=i)
			gen_multi(gen_fmul, fs, noise=i)
	else:
		gen_multi(gen_pt, pts, noise=None)
		gen_multi(gen_am, ams, noise=None)
		gen_multi(gen_chirps, chirps, noise=None)
		gen_multi(gen_steps, steps, noise=None)
		gen_multi(gen_fmul, fs, noise=None)
